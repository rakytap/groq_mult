import numpy as np

#default values for bit splitting
bitchunk = 7
num_of_chunks = 9
full_bitwidth = 50#num_of_chunks*bitchunk
bound = pow(2, full_bitwidth)

# default values for folating point bit splitting
double_mantissa_bits = 52
double_exponent_bias = 1023


# function to split higher bitwidth array into int8 array bit-slices
# the shape of the return value is (number of chunks in rows, number of rows in one chunk, number of chunks in cols, number of cols in one chunk)
# todo: check if inp is a two-dimensional array
def divide_into_bitchunks(inp, num_of_chunks):

    # determine the dimensions of the return
    shape = (num_of_chunks,) + inp.shape

    sign_bits = np.sign(inp)
    sign_bits = (np.abs(sign_bits) - sign_bits)/2
    sign_bits = sign_bits.astype(np.int8)
    #print( sign_bits[:,0:10] )
    #print(inp)
    inp_loc = inp.copy()
    #print(inp_loc)



    # reserve space for the return
    ret = np.zeros(shape, dtype=np.int8)
    
    
    for chunk in range(num_of_chunks):

        # extract decimal bits
        for bit_idx in range(bitchunk):
            bit = (inp_loc % 2)
            ret[chunk] += pow(2,bit_idx)*bit
            inp_loc = np.right_shift(inp_loc,1)

        
        # adding sign bit
        if( chunk == num_of_chunks-1) :
            bit = (inp_loc % 2)
            ret[chunk] = (ret[chunk].astype(np.uint8) + pow(2,bitchunk)*bit).astype(np.int8)
                

    shape_new = ( shape[0], shape[1], 1, shape[2] )
    ret = ret.reshape(shape_new)
    return ret


# function to combine int8 bitchunks generated by divide_into_bitchunks into 64bit integer
# the shape of the input should be (number of chunks in rows, number of rows in one chunk, number of chunks in cols, number of cols in one chunk)
def combine_bitchunks_into_integer(bit_chunks):

    shape_inp = bit_chunks.shape
    chunk_num_in_rows = shape_inp[0]
    chunk_num_in_cols = shape_inp[2]

    result_64 = np.zeros((shape_inp[1], shape_inp[3]), dtype=np.int64)
    for idx in range(chunk_num_in_rows):
        for jdx in range(chunk_num_in_cols):
            power = bitchunk*(idx+jdx)
            if ( power > 64 ):
                print('Overflow in combining bitchunks into 64bit integer')

            result_64 += np.left_shift(bit_chunks[idx,:,jdx,:].astype(np.int64), power)


    return result_64



# function to convert the mantissa bits of double precision floating point array into int8 array bit-slices
def divide_double_into_bitchunks(inp, num_of_chunks):

    # determine common 2-base exponent for the array
    inp_abs = np.abs(inp).reshape( (inp.size,))
 
    exponent = 0 # 2 base exponent
    while np.max( inp_abs ) > 1.0:
        exponent += 1
        inp_abs = inp_abs/2

    while True:
        inp_abs = inp_abs*2
        if ( np.max( inp_abs ) > 1.0 ):
            break

        exponent -= 1        
    
    #print(exponent)
    

    inp_mantissa = (np.ceil(inp * pow(2, double_mantissa_bits-exponent))).astype(np.int64)

    #print(inp)
    #print(inp_mantissa)
    #print( inp_mantissa.astype(np.float64)/pow(2, double_mantissa_bits-exponent) )


    # create 8 bit chunks of the mantissa
    inp_mantissa_8 = divide_into_bitchunks(inp_mantissa, num_of_chunks)


    return inp_mantissa_8, exponent



# function to combine int8 bitchunks generated by divide_double_into_bitchunks into double precision floating point array
# the shape of the input should be (number of chunks in rows, number of rows in one chunk, number of chunks in cols, number of cols in one chunk)
def combine_bitchunks_into_double(bit_chunks, exponent):


    shape_inp = bit_chunks.shape
    chunk_num_in_rows = shape_inp[0]
    chunk_num_in_cols = shape_inp[2]

    ret = np.zeros((shape_inp[1], shape_inp[3]), dtype=np.float64)
    for idx in range(chunk_num_in_rows):
        for jdx in range(chunk_num_in_cols):
            
            power = bitchunk*(idx+jdx) - double_mantissa_bits + exponent
            ret += bit_chunks[idx,:,jdx,:].astype(np.float64) * pow(2.0, power)

    return ret



