import numpy as np

#default values for bit splitting
bitchunk = 7
num_of_chunks = 9
full_bitwidth = 50#num_of_chunks*bitchunk
bound = pow(2, full_bitwidth)

# default values for folating point bit splitting
double_mantissa_bits = 52
double_exponent_bias = 1023


# function to split higher bitwidth array into int8 array bit-slices
# the shape of the return value is (number of chunks in rows, number of rows in one chunk, number of chunks in cols, number of cols in one chunk)
# todo: check if inp is a two-dimensional array
def divide_into_bitchunks(inp, num_of_chunks):

    # determine the dimensions of the return
    shape = (num_of_chunks,) + inp.shape

    sign_bits = np.sign(inp)
    sign_bits = (np.abs(sign_bits) - sign_bits)/2
    sign_bits = sign_bits.astype(np.int8)
    #print( sign_bits[:,0:10] )
    #print(inp)
    inp_loc = inp.copy()
    #print(inp_loc)



    # reserve space for the return
    ret = np.zeros(shape, dtype=np.int8)
    
    
    for chunk in range(num_of_chunks):

        # extract decimal bits
        for bit_idx in range(bitchunk):
            bit = (inp_loc % 2)
            ret[chunk] += pow(2,bit_idx)*bit
            inp_loc = np.right_shift(inp_loc,1)

        
        # adding sign bit
        if( chunk == num_of_chunks-1) :
            bit = (inp_loc % 2)
            ret[chunk] = (ret[chunk].astype(np.uint8) + pow(2,bitchunk)*bit).astype(np.int8)
                

    shape_new = ( shape[0], shape[1], 1, shape[2] )
    ret = ret.reshape(shape_new)
    return ret


# function to combine int8 bitchunks generated by divide_into_bitchunks into 64bit integer
# the shape of the input should be (number of chunks in rows, number of rows in one chunk, number of chunks in cols, number of cols in one chunk)
def combine_bitchunks_into_integer(bit_chunks):

    shape_inp = bit_chunks.shape
    chunk_num_in_rows = shape_inp[0]
    chunk_num_in_cols = shape_inp[2]

    result_64 = np.zeros((shape_inp[1], shape_inp[3]), dtype=np.int64)
    for idx in range(chunk_num_in_rows):
        for jdx in range(chunk_num_in_cols):
            power = bitchunk*(idx+jdx)
            if ( power > 64 ):
                print('Overflow in combining bitchunks into 64bit integer')

            result_64 += np.left_shift(bit_chunks[idx,:,jdx,:].astype(np.int64), power)


    return result_64



# function to convert the mantissa bits of double precision floating point array into int8 array bit-slices
def divide_double_into_bitchunks(inp, num_of_chunks):

    # determine common 2-base exponent for the array
    inp_abs = np.abs(inp).reshape( (inp.size,))
 
    exponent = 0 # 2 base exponent
    while np.max( inp_abs ) > 1.0:
        exponent += 1
        inp_abs = inp_abs/2

    while True:
        inp_abs = inp_abs*2
        if ( np.max( inp_abs ) > 1.0 ):
            break

        exponent -= 1        
    
    #print(exponent)
    

    inp_mantissa = (np.ceil(inp * pow(2, double_mantissa_bits-exponent))).astype(np.int64)

    #print(inp)
    #print(inp_mantissa)
    #print( inp_mantissa.astype(np.float64)/pow(2, double_mantissa_bits-exponent) )


    # create 8 bit chunks of the mantissa
    inp_mantissa_8 = divide_into_bitchunks(inp_mantissa, num_of_chunks)


    return inp_mantissa_8, exponent



# function to combine int8 bitchunks generated by divide_double_into_bitchunks into double precision floating point array
# the shape of the input should be (number of chunks in rows, number of rows in one chunk, number of chunks in cols, number of cols in one chunk)
def combine_bitchunks_into_double(bit_chunks, exponent):


    shape_inp = bit_chunks.shape
    chunk_num_in_rows = shape_inp[0]
    chunk_num_in_cols = shape_inp[2]

    ret = np.zeros((shape_inp[1], shape_inp[3]), dtype=np.float64)
    for idx in range(chunk_num_in_rows):
        for jdx in range(chunk_num_in_cols):
            
            power = bitchunk*(idx+jdx) - double_mantissa_bits + exponent
            ret += bit_chunks[idx,:,jdx,:].astype(np.float64) * pow(2.0, power)

    return ret




# function to prototype the combination of groq result into the final result returned to the CPU -- this logic should be implemented on the Groq chip
# the shape of the input should be (number of chunks in rows, number of rows in one chunk, number of chunks in cols, number of cols in one chunk)
def convert_groq_result_to_double(bit_chunks, exponent):

    shape_inp = bit_chunks.shape
    chunk_num_in_rows = shape_inp[0]
    chunk_num_in_cols = shape_inp[2]

    
    # number full of ones used to extract the least significant 7 bits of the chunks
    bits_extract = int(pow(2, bitchunk))-1

    '''
    # 8-bit reduction of bitchunks preventing overflows
    bit_chunks_8 = bit_chunks.copy()

    array_extract = np.ones( (shape_inp[1], shape_inp[2], shape_inp[3]), dtype=np.int32 ) * bits_extract  
    for idx in range(chunk_num_in_rows-1):
        extracted_row = np.bitwise_and( bit_chunks_8[idx, :, :, :],  array_extract)
    
        #print( extracted_row[0,0,0:4] )
        #print( bit_chunks[idx,0,0,0:4] )
        #print( bit_chunks[idx+1,0,0,0:4] )
    
        bit_chunks_8[idx, :, :, :] = np.right_shift(bit_chunks_8[idx, :, :, :], bitchunk)
        bit_chunks_8[idx+1, :, :, :] = bit_chunks_8[idx+1, :, :, :] + bit_chunks_8[idx, :, :, :]
        bit_chunks_8[idx, :, :, :] = extracted_row

        #print( bit_chunks_8[idx,0,0,0:4] )
        #print( bit_chunks_8[idx+1,0,0,0:4] )

    bit_chunks_8 = bit_chunks_8.astype(np.int8)
    '''
    
    
    bit_chunks_8 = bit_chunks.copy()
    
        
    #####return bit_chunks_8, exponent

    reduced2 = bit_chunks_8[:,:,0,:].copy()
    



    for jdx in range(1, chunk_num_in_cols):
        tmp = reduced2.astype(np.int32)
        reduced2 = bit_chunks_8[:,:,jdx,:].astype(np.int32)
        reduced2[0:chunk_num_in_rows-1,:,:] += tmp[1:chunk_num_in_rows,:,:]

    
    reduced2 = reduced2.reshape( (shape_inp[0], shape_inp[1], 1, shape_inp[3]) )
    exponent_modified = exponent + bitchunk*(chunk_num_in_cols-1)

    ####return reduced2, exponent_modified

    reduced_8 = reduced2.copy()

    array_extract = np.ones( (shape_inp[1], 1, shape_inp[3]), dtype=np.int32 ) * bits_extract
    for idx in range(chunk_num_in_rows-1):
        extracted_row = np.bitwise_and( reduced_8[idx, :, :, :],  array_extract)
    
        reduced_8[idx, :, :, :] = np.right_shift(reduced_8[idx, :, :, :], bitchunk)
        reduced_8[idx+1, :, :, :] = reduced_8[idx+1, :, :, :] + reduced_8[idx, :, :, :]
        reduced_8[idx, :, :, :] = extracted_row


    reduced_8 = reduced_8.astype(np.int8)


    

    return reduced_8, exponent_modified
    




